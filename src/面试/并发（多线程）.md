>线程总共有5大状态

    新建状态：新建线程对象，并没有调用start()方法之前

    就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态哦。

    运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态

    阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态

    死亡状态：线程执行结束

>锁的类型

    可重入锁：在执行对象中所有同步方法不用再次获得锁

    可中断锁：在等待获取锁过程中可中断

    公平锁： 按等待获取锁的线程的等待时间进行获取，
                等待时间长的具有优先获取锁权利

    读写锁：对资源读取和写入的时候拆分为2部分处理，
                读的时候可以多线程一起读，写的时候必须同步地写

>同步方法和同步代码块的区别是什么？

    区别：
    1、同步方法默认用this或者当前类class对象作为锁；
    2、同步代码块可以选择以什么来加锁，比同步方法要
    更细颗粒度，我们可以选择只同步会发生同步问题的
    部分代码而不是整个方法；
    3、同步方法使用关键字synchronized修饰方法，
    而同步代码块主要是修饰需要进行同步的代码，
    用  synchronized（object）{代码内容}进行修饰；

>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

    监视器和锁在Java虚拟机中是一块使用的。监视器
    监视一块同步代码块，确保一次只有一个线程执行
    同步代码块。每一个监视器都和一个对象引用相关联。
    线程在获取锁之前不允许执行同步代码。

>什么是死锁(deadlock)？

    所谓死锁是指多个进程因竞争资源而造成的一种僵局
    （互相等待），若无外力作用，这些进程都将无法向前推进。
    死锁产生的4个必要条件：

    1、互斥条件：进程要求对所分配的资源（如打印机）
    进行排他性控制，即在一段时间内某资源仅为一个进程所占有。
    此时若有其他进程请求该资源，则请求进程只能等待。

    2、不剥夺条件：进程所获得的资源在未使用完毕之前，
    不能被其他进程强行夺走，即只能
    由获得该资源的进程自己来释放（只能是主动释放)。

    3、请求和保持条件：进程已经保持了至少一个资源，
    但又提出了新的资源请求，而该资源
    已被其他进程占有，此时请求进程被阻塞，
    但对自己已获得的资源保持不放。

    4、循环等待条件：存在一种进程资源的循环等待链，
    链中每一个进程已获得的资源同时被
    链中下一个进程所请求。

##### Synchronized和Lock的区别
    1、Lock是java的一个interface接口，而synchronized是Java中的关键字，
    synchronized是由JDK实现的，不需要程序员编写代码去控制加锁和释放；

    2、synchronized修饰的代码在执行异常时，jdk会自动释放线程
    占有的锁，不需要程序员去控制释放锁，因此不会导致死锁现象发生；
    但是，当Lock发生异常时，如果程序没有通过unLock()去释放锁，
    则很可能造成死锁现象，因此Lock一般都是在finally块中释放锁；

    3、Lock可以让等待锁的线程响应中断处理，如tryLock(long time,
     TimeUnit unit)，而synchronized却不行，使用synchronized时，
     等待的线程会一直等待下去，不能够中断，无法控制；

     4、通过Lock可以知道有没有成功获取锁，tryLock()方法返回
     boolean值，因此可知道是否获得了锁，而synchronized
     却无法办到。

     5、synchronize底层是悲观锁，利用
     monitorenter和monitorexit两个指令来实现同步，而
     lock是利用volatile和CAS乐观锁原理实现同步。
